import { ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';
import { NgControl } from '@angular/forms';
import { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';
import { TypeaheadContainerComponent } from './typeahead-container.component';
import { TypeaheadMatch } from './typeahead-match.class';
import { TypeaheadConfig } from './typeahead.config';
import * as ɵngcc0 from '@angular/core';
export declare class TypeaheadDirective implements OnInit, OnDestroy {
    private changeDetection;
    private element;
    private ngControl;
    private renderer;
    /** options source, can be Array of strings, objects or
     * an Observable for external matching process
     */
    typeahead: any;
    /** minimal no of characters that needs to be entered before
     * typeahead kicks-in. When set to 0, typeahead shows on focus with full
     * list of options (limited as normal by typeaheadOptionsLimit)
     */
    typeaheadMinLength: number;
    /** sets use adaptive position */
    adaptivePosition: boolean;
    /** turn on/off animation */
    isAnimated: boolean;
    /** minimal wait time after last character typed before typeahead kicks-in */
    typeaheadWaitMs: number;
    /** maximum length of options items list. The default value is 20 */
    typeaheadOptionsLimit: number;
    /** when options source is an array of objects, the name of field
     * that contains the options value, we use array item as option in case
     * of this field is missing. Supports nested properties and methods.
     */
    typeaheadOptionField: string;
    /** when options source is an array of objects, the name of field that
     * contains the group value, matches are grouped by this field when set.
     */
    typeaheadGroupField: string;
    /** should be used only in case of typeahead attribute is Observable of array.
     * If true - loading of options will be async, otherwise - sync.
     * true make sense if options array is large.
     */
    typeaheadAsync: boolean;
    /** match latin symbols.
     * If true the word súper would match super and vice versa.
     */
    typeaheadLatinize: boolean;
    /** Can be use to search words by inserting a single white space between each characters
     *  for example 'C a l i f o r n i a' will match 'California'.
     */
    typeaheadSingleWords: boolean;
    /** should be used only in case typeaheadSingleWords attribute is true.
     * Sets the word delimiter to break words. Defaults to space.
     */
    typeaheadWordDelimiters: string;
    /** should be used only in case typeaheadSingleWords attribute is true.
     * Sets the word delimiter to match exact phrase.
     * Defaults to simple and double quotes.
     */
    typeaheadPhraseDelimiters: string;
    /** used to specify a custom item template.
     * Template variables exposed are called item and index;
     */
    typeaheadItemTemplate: TemplateRef<any>;
    /** used to specify a custom options list template.
     * Template variables: matches, itemTemplate, query
     */
    optionsListTemplate: TemplateRef<any>;
    /** specifies if typeahead is scrollable  */
    typeaheadScrollable: boolean;
    /** specifies number of options to show in scroll view  */
    typeaheadOptionsInScrollableView: number;
    /** used to hide result on blur */
    typeaheadHideResultsOnBlur: boolean;
    /** fired when an options list was opened and the user clicked Tab
     * If a value equal true, it will be chosen first or active item in the list
     * If value equal false, it will be chosen an active item in the list or nothing
     */
    typeaheadSelectFirstItem: boolean;
    /** makes active first item in a list */
    typeaheadIsFirstItemActive: boolean;
    /** fired when 'busy' state of this component was changed,
     * fired on async mode only, returns boolean
     */
    typeaheadLoading: EventEmitter<boolean>;
    /** fired on every key event and returns true
     * in case of matches are not detected
     */
    typeaheadNoResults: EventEmitter<boolean>;
    /** fired when option was selected, return object with data of this option */
    typeaheadOnSelect: EventEmitter<TypeaheadMatch>;
    /** fired when blur event occurs. returns the active item */
    typeaheadOnBlur: EventEmitter<any>;
    /**
     * A selector specifying the element the typeahead should be appended to.
     */
    container: string;
    /** This attribute indicates that the dropdown should be opened upwards */
    dropup: boolean;
    /** if false restrict model values to the ones selected from the popup only will be provided */
    /** if false the first match automatically will not be focused as you type */
    /** format the ng-model result after selection */
    /** if true automatically select an item when there is one option that exactly matches the user input */
    /**  if true select the currently highlighted match on blur */
    /**  if false don't focus the input element the typeahead directive is associated with on selection */
    _container: TypeaheadContainerComponent;
    isActiveItemChanged: boolean;
    isTypeaheadOptionsListActive: boolean;
    protected keyUpEventEmitter: EventEmitter<any>;
    protected _matches: TypeaheadMatch[];
    protected placement: string;
    private _typeahead;
    private _subscriptions;
    private _outsideClickListener;
    constructor(cis: ComponentLoaderFactory, config: TypeaheadConfig, changeDetection: ChangeDetectorRef, element: ElementRef, ngControl: NgControl, renderer: Renderer2, viewContainerRef: ViewContainerRef);
    ngOnInit(): void;
    onInput(e: any): void;
    onChange(event: KeyboardEvent): void;
    onFocus(): void;
    onBlur(): void;
    onKeydown(event: KeyboardEvent): void;
    changeModel(match: TypeaheadMatch): void;
    readonly matches: TypeaheadMatch[];
    show(): void;
    hide(): void;
    onOutsideClick(): void;
    ngOnDestroy(): void;
    protected asyncActions(): void;
    protected syncActions(): void;
    protected normalizeOption(option: any): any;
    protected normalizeQuery(value: string): string | string[];
    protected testMatch(match: string, test: string[] | string): boolean;
    protected finalizeAsyncCall(matches: TypeaheadMatch[]): void;
    protected prepareMatches(options: TypeaheadMatch[]): void;
    protected hasMatches(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<TypeaheadDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<TypeaheadDirective, "[typeahead]", ["bs-typeahead"], {
    "typeaheadMinLength": "typeaheadMinLength";
    "isAnimated": "isAnimated";
    "typeaheadAsync": "typeaheadAsync";
    "typeaheadLatinize": "typeaheadLatinize";
    "typeaheadSingleWords": "typeaheadSingleWords";
    "typeaheadWordDelimiters": "typeaheadWordDelimiters";
    "typeaheadPhraseDelimiters": "typeaheadPhraseDelimiters";
    "typeaheadScrollable": "typeaheadScrollable";
    "typeaheadOptionsInScrollableView": "typeaheadOptionsInScrollableView";
    "typeaheadSelectFirstItem": "typeaheadSelectFirstItem";
    "typeaheadIsFirstItemActive": "typeaheadIsFirstItemActive";
    "dropup": "dropup";
    "typeaheadOptionsLimit": "typeaheadOptionsLimit";
    "typeaheadWaitMs": "typeaheadWaitMs";
    "typeahead": "typeahead";
    "adaptivePosition": "adaptivePosition";
    "typeaheadOptionField": "typeaheadOptionField";
    "typeaheadGroupField": "typeaheadGroupField";
    "typeaheadItemTemplate": "typeaheadItemTemplate";
    "optionsListTemplate": "optionsListTemplate";
    "typeaheadHideResultsOnBlur": "typeaheadHideResultsOnBlur";
    "container": "container";
}, {
    "typeaheadLoading": "typeaheadLoading";
    "typeaheadNoResults": "typeaheadNoResults";
    "typeaheadOnSelect": "typeaheadOnSelect";
    "typeaheadOnBlur": "typeaheadOnBlur";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZWFoZWFkLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJ0eXBlYWhlYWQuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnSUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IENvbXBvbmVudExvYWRlckZhY3RvcnkgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2NvbXBvbmVudC1sb2FkZXInO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL3R5cGVhaGVhZC1jb250YWluZXIuY29tcG9uZW50JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkTWF0Y2ggfSBmcm9tICcuL3R5cGVhaGVhZC1tYXRjaC5jbGFzcyc7XHJcbmltcG9ydCB7IFR5cGVhaGVhZENvbmZpZyB9IGZyb20gJy4vdHlwZWFoZWFkLmNvbmZpZyc7XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFR5cGVhaGVhZERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0aW9uO1xyXG4gICAgcHJpdmF0ZSBlbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2w7XHJcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xyXG4gICAgLyoqIG9wdGlvbnMgc291cmNlLCBjYW4gYmUgQXJyYXkgb2Ygc3RyaW5ncywgb2JqZWN0cyBvclxyXG4gICAgICogYW4gT2JzZXJ2YWJsZSBmb3IgZXh0ZXJuYWwgbWF0Y2hpbmcgcHJvY2Vzc1xyXG4gICAgICovXHJcbiAgICB0eXBlYWhlYWQ6IGFueTtcclxuICAgIC8qKiBtaW5pbWFsIG5vIG9mIGNoYXJhY3RlcnMgdGhhdCBuZWVkcyB0byBiZSBlbnRlcmVkIGJlZm9yZVxyXG4gICAgICogdHlwZWFoZWFkIGtpY2tzLWluLiBXaGVuIHNldCB0byAwLCB0eXBlYWhlYWQgc2hvd3Mgb24gZm9jdXMgd2l0aCBmdWxsXHJcbiAgICAgKiBsaXN0IG9mIG9wdGlvbnMgKGxpbWl0ZWQgYXMgbm9ybWFsIGJ5IHR5cGVhaGVhZE9wdGlvbnNMaW1pdClcclxuICAgICAqL1xyXG4gICAgdHlwZWFoZWFkTWluTGVuZ3RoOiBudW1iZXI7XHJcbiAgICAvKiogc2V0cyB1c2UgYWRhcHRpdmUgcG9zaXRpb24gKi9cclxuICAgIGFkYXB0aXZlUG9zaXRpb246IGJvb2xlYW47XHJcbiAgICAvKiogdHVybiBvbi9vZmYgYW5pbWF0aW9uICovXHJcbiAgICBpc0FuaW1hdGVkOiBib29sZWFuO1xyXG4gICAgLyoqIG1pbmltYWwgd2FpdCB0aW1lIGFmdGVyIGxhc3QgY2hhcmFjdGVyIHR5cGVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW4gKi9cclxuICAgIHR5cGVhaGVhZFdhaXRNczogbnVtYmVyO1xyXG4gICAgLyoqIG1heGltdW0gbGVuZ3RoIG9mIG9wdGlvbnMgaXRlbXMgbGlzdC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMjAgKi9cclxuICAgIHR5cGVhaGVhZE9wdGlvbnNMaW1pdDogbnVtYmVyO1xyXG4gICAgLyoqIHdoZW4gb3B0aW9ucyBzb3VyY2UgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG5hbWUgb2YgZmllbGRcclxuICAgICAqIHRoYXQgY29udGFpbnMgdGhlIG9wdGlvbnMgdmFsdWUsIHdlIHVzZSBhcnJheSBpdGVtIGFzIG9wdGlvbiBpbiBjYXNlXHJcbiAgICAgKiBvZiB0aGlzIGZpZWxkIGlzIG1pc3NpbmcuIFN1cHBvcnRzIG5lc3RlZCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICB0eXBlYWhlYWRPcHRpb25GaWVsZDogc3RyaW5nO1xyXG4gICAgLyoqIHdoZW4gb3B0aW9ucyBzb3VyY2UgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG5hbWUgb2YgZmllbGQgdGhhdFxyXG4gICAgICogY29udGFpbnMgdGhlIGdyb3VwIHZhbHVlLCBtYXRjaGVzIGFyZSBncm91cGVkIGJ5IHRoaXMgZmllbGQgd2hlbiBzZXQuXHJcbiAgICAgKi9cclxuICAgIHR5cGVhaGVhZEdyb3VwRmllbGQ6IHN0cmluZztcclxuICAgIC8qKiBzaG91bGQgYmUgdXNlZCBvbmx5IGluIGNhc2Ugb2YgdHlwZWFoZWFkIGF0dHJpYnV0ZSBpcyBPYnNlcnZhYmxlIG9mIGFycmF5LlxyXG4gICAgICogSWYgdHJ1ZSAtIGxvYWRpbmcgb2Ygb3B0aW9ucyB3aWxsIGJlIGFzeW5jLCBvdGhlcndpc2UgLSBzeW5jLlxyXG4gICAgICogdHJ1ZSBtYWtlIHNlbnNlIGlmIG9wdGlvbnMgYXJyYXkgaXMgbGFyZ2UuXHJcbiAgICAgKi9cclxuICAgIHR5cGVhaGVhZEFzeW5jOiBib29sZWFuO1xyXG4gICAgLyoqIG1hdGNoIGxhdGluIHN5bWJvbHMuXHJcbiAgICAgKiBJZiB0cnVlIHRoZSB3b3JkIHPDunBlciB3b3VsZCBtYXRjaCBzdXBlciBhbmQgdmljZSB2ZXJzYS5cclxuICAgICAqL1xyXG4gICAgdHlwZWFoZWFkTGF0aW5pemU6IGJvb2xlYW47XHJcbiAgICAvKiogQ2FuIGJlIHVzZSB0byBzZWFyY2ggd29yZHMgYnkgaW5zZXJ0aW5nIGEgc2luZ2xlIHdoaXRlIHNwYWNlIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJzXHJcbiAgICAgKiAgZm9yIGV4YW1wbGUgJ0MgYSBsIGkgZiBvIHIgbiBpIGEnIHdpbGwgbWF0Y2ggJ0NhbGlmb3JuaWEnLlxyXG4gICAgICovXHJcbiAgICB0eXBlYWhlYWRTaW5nbGVXb3JkczogYm9vbGVhbjtcclxuICAgIC8qKiBzaG91bGQgYmUgdXNlZCBvbmx5IGluIGNhc2UgdHlwZWFoZWFkU2luZ2xlV29yZHMgYXR0cmlidXRlIGlzIHRydWUuXHJcbiAgICAgKiBTZXRzIHRoZSB3b3JkIGRlbGltaXRlciB0byBicmVhayB3b3Jkcy4gRGVmYXVsdHMgdG8gc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHR5cGVhaGVhZFdvcmREZWxpbWl0ZXJzOiBzdHJpbmc7XHJcbiAgICAvKiogc2hvdWxkIGJlIHVzZWQgb25seSBpbiBjYXNlIHR5cGVhaGVhZFNpbmdsZVdvcmRzIGF0dHJpYnV0ZSBpcyB0cnVlLlxyXG4gICAgICogU2V0cyB0aGUgd29yZCBkZWxpbWl0ZXIgdG8gbWF0Y2ggZXhhY3QgcGhyYXNlLlxyXG4gICAgICogRGVmYXVsdHMgdG8gc2ltcGxlIGFuZCBkb3VibGUgcXVvdGVzLlxyXG4gICAgICovXHJcbiAgICB0eXBlYWhlYWRQaHJhc2VEZWxpbWl0ZXJzOiBzdHJpbmc7XHJcbiAgICAvKiogdXNlZCB0byBzcGVjaWZ5IGEgY3VzdG9tIGl0ZW0gdGVtcGxhdGUuXHJcbiAgICAgKiBUZW1wbGF0ZSB2YXJpYWJsZXMgZXhwb3NlZCBhcmUgY2FsbGVkIGl0ZW0gYW5kIGluZGV4O1xyXG4gICAgICovXHJcbiAgICB0eXBlYWhlYWRJdGVtVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICAvKiogdXNlZCB0byBzcGVjaWZ5IGEgY3VzdG9tIG9wdGlvbnMgbGlzdCB0ZW1wbGF0ZS5cclxuICAgICAqIFRlbXBsYXRlIHZhcmlhYmxlczogbWF0Y2hlcywgaXRlbVRlbXBsYXRlLCBxdWVyeVxyXG4gICAgICovXHJcbiAgICBvcHRpb25zTGlzdFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgLyoqIHNwZWNpZmllcyBpZiB0eXBlYWhlYWQgaXMgc2Nyb2xsYWJsZSAgKi9cclxuICAgIHR5cGVhaGVhZFNjcm9sbGFibGU6IGJvb2xlYW47XHJcbiAgICAvKiogc3BlY2lmaWVzIG51bWJlciBvZiBvcHRpb25zIHRvIHNob3cgaW4gc2Nyb2xsIHZpZXcgICovXHJcbiAgICB0eXBlYWhlYWRPcHRpb25zSW5TY3JvbGxhYmxlVmlldzogbnVtYmVyO1xyXG4gICAgLyoqIHVzZWQgdG8gaGlkZSByZXN1bHQgb24gYmx1ciAqL1xyXG4gICAgdHlwZWFoZWFkSGlkZVJlc3VsdHNPbkJsdXI6IGJvb2xlYW47XHJcbiAgICAvKiogZmlyZWQgd2hlbiBhbiBvcHRpb25zIGxpc3Qgd2FzIG9wZW5lZCBhbmQgdGhlIHVzZXIgY2xpY2tlZCBUYWJcclxuICAgICAqIElmIGEgdmFsdWUgZXF1YWwgdHJ1ZSwgaXQgd2lsbCBiZSBjaG9zZW4gZmlyc3Qgb3IgYWN0aXZlIGl0ZW0gaW4gdGhlIGxpc3RcclxuICAgICAqIElmIHZhbHVlIGVxdWFsIGZhbHNlLCBpdCB3aWxsIGJlIGNob3NlbiBhbiBhY3RpdmUgaXRlbSBpbiB0aGUgbGlzdCBvciBub3RoaW5nXHJcbiAgICAgKi9cclxuICAgIHR5cGVhaGVhZFNlbGVjdEZpcnN0SXRlbTogYm9vbGVhbjtcclxuICAgIC8qKiBtYWtlcyBhY3RpdmUgZmlyc3QgaXRlbSBpbiBhIGxpc3QgKi9cclxuICAgIHR5cGVhaGVhZElzRmlyc3RJdGVtQWN0aXZlOiBib29sZWFuO1xyXG4gICAgLyoqIGZpcmVkIHdoZW4gJ2J1c3knIHN0YXRlIG9mIHRoaXMgY29tcG9uZW50IHdhcyBjaGFuZ2VkLFxyXG4gICAgICogZmlyZWQgb24gYXN5bmMgbW9kZSBvbmx5LCByZXR1cm5zIGJvb2xlYW5cclxuICAgICAqL1xyXG4gICAgdHlwZWFoZWFkTG9hZGluZzogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xyXG4gICAgLyoqIGZpcmVkIG9uIGV2ZXJ5IGtleSBldmVudCBhbmQgcmV0dXJucyB0cnVlXHJcbiAgICAgKiBpbiBjYXNlIG9mIG1hdGNoZXMgYXJlIG5vdCBkZXRlY3RlZFxyXG4gICAgICovXHJcbiAgICB0eXBlYWhlYWROb1Jlc3VsdHM6IEV2ZW50RW1pdHRlcjxib29sZWFuPjtcclxuICAgIC8qKiBmaXJlZCB3aGVuIG9wdGlvbiB3YXMgc2VsZWN0ZWQsIHJldHVybiBvYmplY3Qgd2l0aCBkYXRhIG9mIHRoaXMgb3B0aW9uICovXHJcbiAgICB0eXBlYWhlYWRPblNlbGVjdDogRXZlbnRFbWl0dGVyPFR5cGVhaGVhZE1hdGNoPjtcclxuICAgIC8qKiBmaXJlZCB3aGVuIGJsdXIgZXZlbnQgb2NjdXJzLiByZXR1cm5zIHRoZSBhY3RpdmUgaXRlbSAqL1xyXG4gICAgdHlwZWFoZWFkT25CbHVyOiBFdmVudEVtaXR0ZXI8YW55PjtcclxuICAgIC8qKlxyXG4gICAgICogQSBzZWxlY3RvciBzcGVjaWZ5aW5nIHRoZSBlbGVtZW50IHRoZSB0eXBlYWhlYWQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBjb250YWluZXI6IHN0cmluZztcclxuICAgIC8qKiBUaGlzIGF0dHJpYnV0ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZHJvcGRvd24gc2hvdWxkIGJlIG9wZW5lZCB1cHdhcmRzICovXHJcbiAgICBkcm9wdXA6IGJvb2xlYW47XHJcbiAgICAvKiogaWYgZmFsc2UgcmVzdHJpY3QgbW9kZWwgdmFsdWVzIHRvIHRoZSBvbmVzIHNlbGVjdGVkIGZyb20gdGhlIHBvcHVwIG9ubHkgd2lsbCBiZSBwcm92aWRlZCAqL1xyXG4gICAgLyoqIGlmIGZhbHNlIHRoZSBmaXJzdCBtYXRjaCBhdXRvbWF0aWNhbGx5IHdpbGwgbm90IGJlIGZvY3VzZWQgYXMgeW91IHR5cGUgKi9cclxuICAgIC8qKiBmb3JtYXQgdGhlIG5nLW1vZGVsIHJlc3VsdCBhZnRlciBzZWxlY3Rpb24gKi9cclxuICAgIC8qKiBpZiB0cnVlIGF1dG9tYXRpY2FsbHkgc2VsZWN0IGFuIGl0ZW0gd2hlbiB0aGVyZSBpcyBvbmUgb3B0aW9uIHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSB1c2VyIGlucHV0ICovXHJcbiAgICAvKiogIGlmIHRydWUgc2VsZWN0IHRoZSBjdXJyZW50bHkgaGlnaGxpZ2h0ZWQgbWF0Y2ggb24gYmx1ciAqL1xyXG4gICAgLyoqICBpZiBmYWxzZSBkb24ndCBmb2N1cyB0aGUgaW5wdXQgZWxlbWVudCB0aGUgdHlwZWFoZWFkIGRpcmVjdGl2ZSBpcyBhc3NvY2lhdGVkIHdpdGggb24gc2VsZWN0aW9uICovXHJcbiAgICBfY29udGFpbmVyOiBUeXBlYWhlYWRDb250YWluZXJDb21wb25lbnQ7XHJcbiAgICBpc0FjdGl2ZUl0ZW1DaGFuZ2VkOiBib29sZWFuO1xyXG4gICAgaXNUeXBlYWhlYWRPcHRpb25zTGlzdEFjdGl2ZTogYm9vbGVhbjtcclxuICAgIHByb3RlY3RlZCBrZXlVcEV2ZW50RW1pdHRlcjogRXZlbnRFbWl0dGVyPGFueT47XHJcbiAgICBwcm90ZWN0ZWQgX21hdGNoZXM6IFR5cGVhaGVhZE1hdGNoW107XHJcbiAgICBwcm90ZWN0ZWQgcGxhY2VtZW50OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIF90eXBlYWhlYWQ7XHJcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb25zO1xyXG4gICAgcHJpdmF0ZSBfb3V0c2lkZUNsaWNrTGlzdGVuZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihjaXM6IENvbXBvbmVudExvYWRlckZhY3RvcnksIGNvbmZpZzogVHlwZWFoZWFkQ29uZmlnLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50OiBFbGVtZW50UmVmLCBuZ0NvbnRyb2w6IE5nQ29udHJvbCwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZik7XHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xyXG4gICAgb25JbnB1dChlOiBhbnkpOiB2b2lkO1xyXG4gICAgb25DaGFuZ2UoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xyXG4gICAgb25Gb2N1cygpOiB2b2lkO1xyXG4gICAgb25CbHVyKCk6IHZvaWQ7XHJcbiAgICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xyXG4gICAgY2hhbmdlTW9kZWwobWF0Y2g6IFR5cGVhaGVhZE1hdGNoKTogdm9pZDtcclxuICAgIHJlYWRvbmx5IG1hdGNoZXM6IFR5cGVhaGVhZE1hdGNoW107XHJcbiAgICBzaG93KCk6IHZvaWQ7XHJcbiAgICBoaWRlKCk6IHZvaWQ7XHJcbiAgICBvbk91dHNpZGVDbGljaygpOiB2b2lkO1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBhc3luY0FjdGlvbnMoKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBzeW5jQWN0aW9ucygpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIG5vcm1hbGl6ZU9wdGlvbihvcHRpb246IGFueSk6IGFueTtcclxuICAgIHByb3RlY3RlZCBub3JtYWxpemVRdWVyeSh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHwgc3RyaW5nW107XHJcbiAgICBwcm90ZWN0ZWQgdGVzdE1hdGNoKG1hdGNoOiBzdHJpbmcsIHRlc3Q6IHN0cmluZ1tdIHwgc3RyaW5nKTogYm9vbGVhbjtcclxuICAgIHByb3RlY3RlZCBmaW5hbGl6ZUFzeW5jQ2FsbChtYXRjaGVzOiBUeXBlYWhlYWRNYXRjaFtdKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBwcmVwYXJlTWF0Y2hlcyhvcHRpb25zOiBUeXBlYWhlYWRNYXRjaFtdKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBoYXNNYXRjaGVzKCk6IGJvb2xlYW47XHJcbn1cclxuIl19